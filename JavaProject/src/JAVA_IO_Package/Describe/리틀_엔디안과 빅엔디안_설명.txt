리틀 엔디안(Little Endianness)과 빅 엔디안(Big Endianness)

에디안(Endianness)이란?
ㅇ 엔디안은 컴퓨터 메모리에 여러 바이트로 이루어진 데이터(예: 정수, 부동 소수점)를 저장하는 방식을 나타낸다.
   크게 두 가지 방식이 존재한다.
   
빅 엔디안(Big Endianness)
ㅇ 가장 중요한 바이트(Most Significant Byte, MSB)를 가장 낮은 주소에 저장한다.
ㅇ 사람이 숫자를 읽는 방식처럼 순서대로 읽는다.
ㅇ 예 0x12345678을 메모리에 저장할 때, 12 34 56 78 순서로 저장된다.

리틀 에디안(Little Endianness)
ㅇ 가장 덜 중요한 바이트(Least Significant Byte, LSB)를 가장 낮은 주소에 저장한다.
ㅇ 예 0x12345678을 메모리에 저장할 때, 78 56 34 12 순서로 저장된다.


리틀 엔디안과 빅 엔디안 바이트를 문자로 변환할 때, CharacterSet(UTF-8, UTF-16과 함께 인코딩과 디코딩 작업의 필요한 요소이다.)

실제 헥사코드로 표현을 해보면 byte -> hax로 변환 하는 작업을 수행 시, 

빅 에디안의 경우  ["가"]를 출력 결과 => [FEFF(에디안 표현) ac00]로 표현이 된다. ( 빅 에디안의 경우, input으로 들어온 데이터의 byte 순서를 정방향으로 읽는다. )
리틀 에디안의 경우 ["가"]를 출력 결과 => [FFFE(에디안 표현) 00ac]로 표현이 되며 ( 리틀 에디안의 경우, input으로 들어온 데이터의 byte 순서를 역방향으로 읽는다. )

System.out.println("가".getBytes("UTF-16BE")); // BE : Big Endianness 표현 
System.out.println("가".getBytes("UTF-16LE")); // LE : Little Endianness 표현

과거 PC의 CPU 아키텍처의 경우는 리틀 에디안 유형의 역방향으로 읽는 처리속도가 빨라서 리틀 에디안 유형으로 데이터를 통신했지만,
요즘 PC의 CPU 아키텍처의 경우는 빅 에디안 유형의 정방향으로 읽는 처리속도가 빠르기 때문에 빅 에디안으로 데이터 통신을 한다.
그렇지만, 오늘날 현재의 PC에서는 대부분의 운영체제와 CPU가 다양한 엔디안을 지원을해서 걱정이 없다.

그런다음 엔디안이 없는 경우는 에디터(Editor)가 들어오는 데이터의 바이트의 패턴을 추측해서 빅 엔디안 또는 리틀 엔디안으로 해석할 수 있다.
하지만, 이 경우는 정확히 100% 알맞게 해석하는 것이 아닌 잘못된 방식으로 해석될 가능성도 있다. ( 추측률 99.5%의 정확도를 가진다. )

ㅇ 자바의 char 타입은 UTF-16 인코딩을 사용한다.
ㅇ 자바 String 클래스도 내부적으로 UTF-16을 사용한다.
ㅇ 시스템의 기본 문자 인코딩은 java.nio.charset.Charset 클래스를 통해 관리되며,
   JVM 설정에 따라 다를 수 있다.







