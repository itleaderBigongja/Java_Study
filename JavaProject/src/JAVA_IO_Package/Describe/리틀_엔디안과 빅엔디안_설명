리틀 엔디안(Little Endianness)과 빅 엔디안(Big Endianness)

에디안(Endianness)이란?
ㅇ 엔디안은 컴퓨터 메모리에 여러 바이트로 이루어진 데이터(예: 정수, 부동 소수점)를 저장하는 방식을 나타낸다.
   크게 두 가지 방식이 존재한다.
   
빅 엔디안(Big Endianness)
ㅇ 가장 중요한 바이트(Most Significant Byte, MSB)를 가장 낮은 주소에 저장
ㅇ 사람이 숫자를 읽는 방식처럼 순서대로 읽는다.
ㅇ 예 Ox12345678을 메모리에 저장할 때, 12 34 56 78 순서로 저장된다.

리틀 에디안(Little Endianness)
ㅇ 가장 덜 중요한 바이트(Least Significant Byte, LSB)를 가장 낮은 주소에 저장한다.
ㅇ 예 Ox12345678을 메모리에 저장할 때, 78 56 34 12 순서로 저장된다.


리틀 엔디안과 빅 엔디안 바이트를 문자로 변환할 때, CharacterSet(UTF-8, UTF-16과 함께 인코딩과 디코딩 작업의 필요한 요소이다.)

실제 헥사코드로 표현을 해보면 byte -> hax로 변환 하는 작업을 수행 시, 

리틀 에디안의 경우 ["가"]를 출력 결과 => [FFFE(에디안 표현) 00ac]로 표현이 되며 ( 리틀 에디안의 경우, input으로 들어온 데이터의 byte 순서를 역방향으로 읽는다. )
빅 에디안의 경우  ["가"]를 출력 결과 => [FEFF(에디안 표현) ac00]로 표현이 된다. ( 빅 에디안의 경우, input으로 들어온 데이터의 byte 순서를 정방향으로 읽는다. )

System.out.println("가".getBytes("UTF-16BE")); // BE : Big Endianness 표현 
System.out.println("가".getBytes("UTF-16LE")); // LE : Little Endianness 표현

옛날PC(Linux)의 CPU의 경우는 리틀 에디안 유형의 역방향으로 읽는 처리속도가 빨라서 리틀 에디안 유형으로 데이터를 통신했지만,
요즘PC(Window)의 CPU의 경우는 빅 에디안 유형의 정방향으로 읽는 처리속도가 빠르기 때문에 빅 에디안으로 데이터 통신을 한다.

하지만, 요즘은 Linux와 Window도 다 발전을 했기 때문에. 서로 유형을 맞춰서 통신을 할수 있다.
리눅스도 빅 엔디안이 가능하고, 윈도우 또한 리틀 엔디안으로 통신을 할 수 있다.

그런다음 엔디안이 없을 경우는 에디터가 들어오는 데이터의 바이트의 패턴을 추측해서 빅 엔디안 또는 리틀 엔디안으로 묵시적으로 바꿔서 통신을할 수 있다.


ㅇ 자바의 char 타입은 UTF-16 인코딩을 사용한다.
ㅇ 자바 String 클래스도 내부적으로 UTF-16을 사용한다.
ㅇ 시스템의 기본 문자 인코딩은 java.nio.charset.Charset 클래스를 통해 관리되며,
   JVM 설정에 따라 다를 수 있다.
  

UTF-16의 확장팩인 UTF-32 == UCS-4







