package thread_5;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/** ExcutorSerivce란?
 *  ExcutorService는 자바에서 스레드 풀(Thread Pool)을 관리하기 위한 인터페이스로,
 *  스레드 생성과 실행 관리를 효율적으로 처리합니다. 일반적으로 직접 스레드를 생성하고 관리하는 대신
 *  ExcutorService를 사용하면, 스레드의 생성/종료/큐 관리 등을 자동으로 처리하여
 *  성능과 안전성을 높일 수 있습니다.
 *  
 *  [ ExcutorService의 특징 ]
 *  1. 스레드 풀(Thread Pool)
 *    ㅇ 미리 생성된 스레드 집합을 사용하여 작업을 처리합니다.
 *    ㅇ 작업이 끝난 스레드는 재사용되어 스레드 생성 비용을 줄이고, 시스템 자원을 효율적으로 사용합니다.
 *    
 *  2. 작업 큐(Work Queue)
 *    ㅇ 작업이 제출되면 실행 대기 상태로 작업 큐에 저장됩니다.
 *       스레드가 사용 가능하면 큐에서 작업을 꺼내 실행합니다.
 *       
 *  3. 자동 관리
 *    ㅇ 스레드 수, 작업 대기, 작업 완료 등을 자동으로 관리하여 개발자가 직접 스레드를 제어할 필요가 없습니다.
 * */
public class ExecutorServiceExample{

	public static void main(String[] args) {
		
		/** Fixed Thread Pool
		 *  ㅇ 고정된 스레드 수로 동작하는 스레드 풀(Thread Pool)을 생성합니다.
		 *  ㅇ 모든 스레드가 바쁠 경우, 작업은 큐(Queue)에 저장됩니다.
		 */ 
		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
		
		try {
			// submit() 메서드로 작업 제출
			Future<String> result1 = fixedThreadPool.submit(() -> {
				Thread.sleep(1000);	// 작업 시뮬레이션
				return "Result from Task 1";
			});
			
			Future<String> result2 = fixedThreadPool.submit(() -> {
				Thread.sleep(1000);
				return "Result from Task 2";
			});
			
			System.out.println("Task 1 Result : " + result1.get()); // 결과 가져오기
			System.out.println("Task 2 Result : " + result2.get());
		} catch (InterruptedException | ExecutionException e) {
			e.printStackTrace();
		} finally {
			fixedThreadPool.shutdown();	// 스레드 풀 종료
		}
		
		/** 2. Cached Thread Pool
		 *  ㅇ 필요할 때 스레드를 생성하고, 사용하지 않으면 스레드를 종료합니다.
		 *  ㅇ 적은 작업량에는 자원을 절약하고, 큰 작업량에는 유연하게 대처할 수 있습니다.
		 *  
		 *  ㅇ invokeAll() 메서드 사용 예제
		 */
		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
		
		List<Callable<String>> tasks = Arrays.asList(
				() -> "Task A",
				() -> "Task B",
				() -> "Task C"
		);
		
		try {
			
		} catch (Exception e) {
			// TODO: handle exception
		}
	}
}	
